"""
Módulo para integração com a API da Starlink
"""

import requests
import time
import json
from datetime import datetime, timedelta

# Configurações para API
AUTH_URL = "https://api.starlink.com/auth/connect/token"

# Configuração de múltiplas contas Starlink
STARLINK_ACCOUNTS = {
    "ACC-3697602-31930-14": {
        "name": "Conta Primária",
        "description": "Conta principal de operações"
    },
    "ACC-3697620-11506-11": {
        "name": "Conta Secundária", 
        "description": "Conta secundária regional"
    },
    "ACC-2744134-64041-5": {
        "name": "Conta Principal",
        "description": "Conta principal consolidada"
    },
    "ACC-3697622-49133-20": {
        "name": "Conta Norte",
        "description": "Conta regional norte"
    },
    "ACC-3697611-48655-26": {
        "name": "Conta Sul",
        "description": "Conta regional sul"
    }
}

# Conta padrão (pode ser alterada via interface)
DEFAULT_ACCOUNT = "ACC-2744134-64041-5"


def get_api_url(account_id=None):
    """
    Constrói a URL da API para uma conta específica
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
    
    return f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}/billing-cycles/query"


def get_account_base_url(account_id=None):
    """
    Constrói a URL base da conta para endpoints específicos
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
    
    return f"https://web-api.starlink.com/enterprise/v1/account/{account_id}"


def get_available_accounts():
    """
    Retorna lista de contas disponíveis
    """
    return STARLINK_ACCOUNTS


def get_account_info(account_id):
    """
    Retorna informações de uma conta específica
    """
    return STARLINK_ACCOUNTS.get(account_id, {
        "name": "Conta Desconhecida",
        "description": "Conta não encontrada"
    })

CLIENT_ID = "498ca080-3eb2-4a4d-a5d9-3828dbef0194"
CLIENT_SECRET = "fibernetworks_api@2025"

token_data = {
    "access_token": None,
    "expires_at": 0
}


def get_token(client_id, client_secret):
    """
    Obtém um novo token de acesso da API Starlink
    """
    payload = {
        "client_id": client_id,
        "client_secret": client_secret,
        "grant_type": "client_credentials"
    }

    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }

    try:
        response = requests.post(AUTH_URL, data=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        expires_in = data.get("expires_in", 0)
        token_data["access_token"] = data.get("access_token")
        token_data["expires_at"] = time.time() + expires_in

        return token_data["access_token"]
    except requests.exceptions.RequestException as e:
        raise Exception(f"Erro ao obter token: {e}")


def get_valid_token():
    """
    Retorna um token válido, renovando se necessário
    """
    if not token_data["access_token"] or time.time() >= token_data["expires_at"]:
        return get_token(CLIENT_ID, CLIENT_SECRET)
    return token_data["access_token"]


def query_service_lines(account_id=None):
    """
    Consulta todos os Service Line Numbers da conta
    """
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_line_numbers = []

        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    service_line_numbers.append(service_line_number)
        
        return service_line_numbers

    except requests.exceptions.RequestException as e:
        raise Exception(f"Erro na requisição à API: {e}")
    except Exception as e:
        raise Exception(f"Erro inesperado: {e}")


def get_service_line_details(service_line_number):
    """
    Obtém detalhes específicos de um Service Line
    """
    # Esta função pode ser expandida conforme necessário
    # Por enquanto, retorna informações básicas
    return {
        "service_line_number": service_line_number,
        "status": "Ativo",
        "last_updated": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    }


def get_billing_summary(account_id=None):
    """
    Obtém resumo de faturamento com dados detalhados
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        if not token:
            return {
                "error": "Não foi possível obter token de acesso",
                "total_service_lines": 0,
                "service_lines": [],
                "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                "account_id": account_id
            }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        total_charges = 0
        billing_cycles = []

        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    # Extrair dados de faturamento
                    billing_info = {
                        "serviceLineNumber": service_line_number,
                        "billing_cycles": result.get("billingCycles", []),
                        "total_amount": 0,
                        "last_billing_date": None
                    }
                    
                    # Processar ciclos de faturamento
                    for cycle in result.get("billingCycles", []):
                        amount = cycle.get("totalAmount", 0)
                        billing_info["total_amount"] += amount
                        total_charges += amount
                        
                        billing_date = cycle.get("billingDate")
                        if billing_date and (not billing_info["last_billing_date"] or billing_date > billing_info["last_billing_date"]):
                            billing_info["last_billing_date"] = billing_date
                    
                    service_lines.append(billing_info)

        return {
            "success": True,
            "total_service_lines": len(service_lines),
            "service_lines": service_lines,
            "total_charges": total_charges,
            "billing_cycles_analyzed": 12,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id,
            "raw_data": data
        }

    except requests.exceptions.RequestException as e:
        return {
            "error": f"Erro na requisição à API: {e}",
            "total_service_lines": 0,
            "service_lines": [],
            "total_charges": 0,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }
    except Exception as e:
        return {
            "error": f"Erro inesperado: {e}",
            "total_service_lines": 0,
            "service_lines": [],
            "total_charges": 0,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }


def test_api_connection(account_id=None):
    """
    Testa a conexão com a API Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        # Primeiro, testa a autenticação
        token = get_valid_token()
        if not token:
            return {
                "status": "error",
                "message": "Falha na autenticação",
                "details": "Não foi possível obter token de acesso",
                "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            }

        # Testa uma requisição simples à API
        payload = {
            "serviceLinesFilter": [],
            "previousBillingCycles": 1,
            "pageIndex": 0,
            "pageLimit": 1
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        
        # Se chegou até aqui, a conexão está OK
        expires_at = datetime.fromtimestamp(token_data['expires_at']).strftime('%d/%m/%Y %H:%M:%S')
        
        return {
            "status": "success",
            "message": "Conexão com API Starlink estabelecida com sucesso",
            "details": f"Token válido até: {expires_at}",
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }

    except requests.exceptions.RequestException as e:
        return {
            "status": "error",
            "message": "Falha na comunicação com a API",
            "details": str(e),
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }
    except Exception as e:
        return {
            "status": "error",
            "message": "Erro inesperado na verificação da API",
            "details": str(e),
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }


def get_detailed_service_lines(account_id=None):
    """
    Obtém lista detalhada de Service Lines com informações completas de localização
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endereços
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    # Extrair informações de localização dos dados da API
                    location_info = "Localização não informada"
                    
                    # Primeiro tentar usar os dados de endereços se houver addressReferenceId
                    address_ref_id = None
                    if "addressReferenceId" in result:
                        address_ref_id = result["addressReferenceId"]
                    elif "serviceLocation" in result and isinstance(result["serviceLocation"], dict):
                        address_ref_id = result["serviceLocation"].get("addressReferenceId")
                    
                    if address_ref_id and address_ref_id in addresses_dict:
                        addr = addresses_dict[address_ref_id]
                        location_parts = []
                        if addr["locality"]:
                            location_parts.append(addr["locality"])
                        if addr["state"]:
                            location_parts.append(addr["state"])
                        if addr["country"]:
                            location_parts.append(addr["country"])
                        
                        if location_parts:
                            location_info = ", ".join(location_parts)
                        elif addr["formatted"]:
                            # Usar endereço formatado como fallback
                            location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                    
                    # Fallback: tentar extrair de outros campos se não encontrou nos endereços
                    if location_info == "Localização não informada":
                        if "nickname" in result and result["nickname"]:
                            location_info = result["nickname"]
                        elif "serviceAddress" in result and result["serviceAddress"]:
                            location_info = str(result["serviceAddress"])
                        elif "latitude" in result and "longitude" in result:
                            location_info = f"GPS: {result['latitude']}, {result['longitude']}"
                    
                    service_lines.append({
                        "index": i,
                        "serviceLineNumber": service_line_number,
                        "status": "Ativo",  # Pode ser expandido com dados reais
                        "serviceLocation": location_info,
                        "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                        "billingCycles": len(result.get("billingCycles", [])),
                        "addressReferenceId": address_ref_id,
                        "rawData": result  # Para debuging ou relatórios detalhados
                    })

        return {
            "success": True,
            "service_lines": service_lines,
            "total": len(service_lines),
            "addresses_loaded": len(addresses_dict),
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Função para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("❌ Não foi possível obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"🔍 Fazendo requisição à API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("📋 RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"📊 Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"📦 Conteúdo disponível: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"📈 Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\n🔸 RESULTADO {i+1}:")
                    print(f"   📋 Campos disponíveis: {list(result.keys())}")
                    
                    # Mostrar campos específicos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   📁 {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   📝 {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ✏️  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localização
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   🗺️  CAMPOS DE LOCALIZAÇÃO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ✅ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("📋 DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"❌ Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint específico de addresses fornecido pelo usuário
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\n🔍 TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n✅ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conteúdo completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n❌ ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n❌ ERRO DE REQUISIÇÃO: {e}")
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        print(f"\n❌ ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa múltiplos endpoints baseados no padrão da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"🔍 Testando endpoint: {endpoint}")
        print(f"📍 URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"📊 Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"✅ Sucesso!")
                print(f"📄 Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"📋 Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"📋 Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"📄 DADOS:")
                print(data)
                
            else:
                print(f"❌ Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"❌ Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obtém todos os endereços cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endereços para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obtém Service Lines com localização correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endereços
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informações de localização
                location_info = "Localização não informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endereços
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endereço formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se não encontrou nos endereços
                if location_info == "Localização não informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se há dados recentes (últimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se não conseguir processar a data, mantém como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estatísticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status possíveis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se há discrepância na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Função para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("❌ Não foi possível obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"🔍 Fazendo requisição à API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("📋 RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"📊 Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"📦 Conteúdo disponível: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"📈 Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\n🔸 RESULTADO {i+1}:")
                    print(f"   📋 Campos disponíveis: {list(result.keys())}")
                    
                    # Mostrar campos específicos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   📁 {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   📝 {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ✏️  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localização
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   🗺️  CAMPOS DE LOCALIZAÇÃO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ✅ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("📋 DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"❌ Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint específico de addresses fornecido pelo usuário
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\n🔍 TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n✅ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conteúdo completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n❌ ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n❌ ERRO DE REQUISIÇÃO: {e}")
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        print(f"\n❌ ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa múltiplos endpoints baseados no padrão da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"🔍 Testando endpoint: {endpoint}")
        print(f"📍 URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"📊 Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"✅ Sucesso!")
                print(f"📄 Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"📋 Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"📋 Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"📄 DADOS:")
                print(data)
                
            else:
                print(f"❌ Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"❌ Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obtém todos os endereços cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endereços para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obtém Service Lines com localização correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endereços
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informações de localização
                location_info = "Localização não informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endereços
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endereço formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se não encontrou nos endereços
                if location_info == "Localização não informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se há dados recentes (últimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se não conseguir processar a data, mantém como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estatísticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status possíveis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se há discrepância na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Função para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("❌ Não foi possível obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"🔍 Fazendo requisição à API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("📋 RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"📊 Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"📦 Conteúdo disponível: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"📈 Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\n🔸 RESULTADO {i+1}:")
                    print(f"   📋 Campos disponíveis: {list(result.keys())}")
                    
                    # Mostrar campos específicos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   📁 {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   📝 {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ✏️  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localização
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   🗺️  CAMPOS DE LOCALIZAÇÃO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ✅ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("📋 DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"❌ Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint específico de addresses fornecido pelo usuário
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\n🔍 TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n✅ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conteúdo completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n❌ ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n❌ ERRO DE REQUISIÇÃO: {e}")
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        print(f"\n❌ ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa múltiplos endpoints baseados no padrão da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"🔍 Testando endpoint: {endpoint}")
        print(f"📍 URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"📊 Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"✅ Sucesso!")
                print(f"📄 Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"📋 Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"📋 Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"📄 DADOS:")
                print(data)
                
            else:
                print(f"❌ Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"❌ Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obtém todos os endereços cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endereços para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obtém Service Lines com localização correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endereços
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informações de localização
                location_info = "Localização não informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endereços
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endereço formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se não encontrou nos endereços
                if location_info == "Localização não informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se há dados recentes (últimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se não conseguir processar a data, mantém como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estatísticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status possíveis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se há discrepância na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisição à API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_service_line_status(account_id=None):
    """
    Debug específico para analisar todos os status possíveis das Service Lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "Não foi possível obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Usar o endpoint correto para Service Lines
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=200"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        print(f"\n🔍 DEBUG - ANÁLISE DE STATUS DAS SERVICE LINES - Conta: {account_id}")
        print("=" * 80)
        
        status_analysis = {}
        field_analysis = {}
        total_lines = 0
        
        if "content" in data and "results" in data["content"]:
            results = data["content"]["results"]
            total_lines = len(results)
            print(f"📊 Total de Service Lines encontradas: {total_lines}")
            
            for i, result in enumerate(results, 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Analisar todos os campos relacionados a status
                fields_of_interest = [
                    'active', 'status', 'state', 'enabled', 'disabled', 'suspended',
                    'startDate', 'endDate', 'activationDate', 'suspensionDate',
                    'billingStatus', 'serviceStatus', 'lineStatus', 'accountStatus',
                    'subscriptionStatus', 'connectionStatus', 'operationalStatus'
                ]
                
                print(f"\n📋 Service Line {i}: {service_line_number}")
                
                # Coletar todos os campos disponíveis
                for field in fields_of_interest:
                    if field in result:
                        value = result[field]
                        print(f"   ✅ {field}: {value}")
                        
                        # Contar ocorrências de cada campo
                        if field not in field_analysis:
                            field_analysis[field] = {}
                        
                        value_str = str(value)
                        if value_str not in field_analysis[field]:
                            field_analysis[field][value_str] = 0
                        field_analysis[field][value_str] += 1
                
                # Determinar status usando lógica melhorada
                determined_status = determine_enhanced_status(result)
                print(f"   🎯 Status Determinado: {determined_status}")
                
                # Contar status
                if determined_status not in status_analysis:
                    status_analysis[determined_status] = 0
                status_analysis[determined_status] += 1
                
                # Mostrar apenas os primeiros 10 para não poluir muito
                if i >= 10:
                    print(f"\n... (mostrando apenas os primeiros 10 de {total_lines})")
                    break
        
        print(f"\n📊 RESUMO DE STATUS:")
        print("-" * 40)
        total_counted = 0
        for status, count in status_analysis.items():
            print(f"   {status}: {count}")
            total_counted += count
        
        print(f"\n📊 Total contabilizado: {total_counted} de {total_lines}")
        if total_counted != total_lines:
            print(f"⚠️  DISCREPÂNCIA: {total_lines - total_counted} Service Lines não contabilizadas!")
        
        print(f"\n📋 ANÁLISE DE CAMPOS:")
        print("-" * 40)
        for field, values in field_analysis.items():
            print(f"   {field}:")
            for value, count in values.items():
                print(f"      {value}: {count}")
        
        return {
            "success": True,
            "total_lines": total_lines,
            "status_analysis": status_analysis,
            "field_analysis": field_analysis,
            "total_counted": total_counted,
            "discrepancy": total_lines - total_counted
        }

    except Exception as e:
        print(f"❌ Erro no debug de status: {e}")
        return {"error": str(e)}


def determine_enhanced_status(service_line_data):
    """
    Determina o status de uma Service Line usando lógica melhorada
    """
    from datetime import datetime, timedelta
    import dateutil.parser
    
    # Verificar campo 'active' primeiro
    active_field = service_line_data.get("active")
    if active_field is False:
        return "Offline"
    
    # Verificar campos de status diretos
    status_fields = ['status', 'state', 'serviceStatus', 'lineStatus', 'operationalStatus']
    for field in status_fields:
        if field in service_line_data:
            value = str(service_line_data[field]).lower()
            if value in ['inactive', 'disabled', 'suspended', 'offline', 'down']:
                return "Offline"
            elif value in ['pending', 'provisioning', 'installing', 'activating']:
                return "Pendente"
            elif value in ['active', 'enabled', 'online', 'up', 'operational']:
                return "Ativo"
    
    # Verificar datas para determinar se está ativo
    try:
        start_date = service_line_data.get("startDate")
        end_date = service_line_data.get("endDate")
        
        if start_date:
            start_datetime = dateutil.parser.parse(start_date)
            now = datetime.now(start_datetime.tzinfo) if start_datetime.tzinfo else datetime.now()
            
            # Se ainda não começou
            if start_datetime > now:
                return "Pendente"
        
        if end_date:
            end_datetime = dateutil.parser.parse(end_date)
            now = datetime.now(end_datetime.tzinfo) if end_datetime.tzinfo else datetime.now()
            
            # Se já terminou há mais de 30 dias
            thirty_days_ago = now - timedelta(days=30)
            if end_datetime < thirty_days_ago:
                return "Sem Dados"
            # Se terminou recentemente
            elif end_datetime < now:
                return "Offline"
    except:
        pass  # Se houver erro no parsing de datas, continua
    
    # Verificar outros campos que podem indicar status
    suspension_date = service_line_data.get("suspensionDate")
    if suspension_date:
        try:
            susp_datetime = dateutil.parser.parse(suspension_date)
            now = datetime.now(susp_datetime.tzinfo) if susp_datetime.tzinfo else datetime.now()
            if susp_datetime <= now:
                return "Suspenso"
        except:
            pass
    
    # Se chegou até aqui e active não é False, assumir ativo
    if active_field is not False:
        return "Ativo"
    
    # Caso padrão
    return "Indeterminado"


def get_billing_usage_data(account_id=None):
    """
    Obtém dados de consumo de franquia do ciclo atual com localização
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Calcular o período do ciclo atual (do dia 3 até hoje)
        today = datetime.now()
        if today.day >= 3:
            cycle_start = today.replace(day=3)
        else:
            # Se estamos antes do dia 3, o ciclo começou no mês anterior
            last_month = today.replace(day=1) - timedelta(days=1)
            cycle_start = last_month.replace(day=3)

        # Primeiro, obter dados dos endereços para correlacionar localização
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Obter dados dos Service Lines com localização
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        service_lines_response = requests.get(service_lines_url, headers=headers)
        service_lines_response.raise_for_status()
        service_lines_data = service_lines_response.json()

        # Criar dicionário de localização por Service Line
        location_dict = {}
        nickname_dict = {}
        
        if "content" in service_lines_data and "results" in service_lines_data["content"]:
            for result in service_lines_data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                if service_line_number:
                    # Obter localização
                    location_info = "Localização não informada"
                    address_ref_id = result.get("addressReferenceId")
                    
                    if address_ref_id and address_ref_id in addresses_dict:
                        addr = addresses_dict[address_ref_id]
                        location_parts = []
                        if addr["locality"]:
                            location_parts.append(addr["locality"])
                        if addr["state"]:
                            location_parts.append(addr["state"])
                        if addr["country"]:
                            location_parts.append(addr["country"])
                        
                        if location_parts:
                            location_info = ", ".join(location_parts)
                        elif addr["formatted"]:
                            location_info = addr["formatted"]
                    
                    # Usar nickname como fallback se não tiver localização
                    nickname = result.get("nickname", "")
                    if nickname and location_info == "Localização não informada":
                        location_info = nickname
                    
                    location_dict[service_line_number] = location_info
                    nickname_dict[service_line_number] = nickname

        # Configurar payload para buscar dados do ciclo atual
        payload = {
            "serviceLinesFilter": [],
            "previousBillingCycles": 1,  # Apenas o ciclo atual
            "pageIndex": 0,
            "pageLimit": 100
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        # Processar dados de consumo
        usage_data = []
        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                total_priority_gb = 0
                total_standard_gb = 0
                
                if "billingCycles" in result:
                    for cycle in result["billingCycles"]:
                        if "dailyDataUsage" in cycle:
                            for usage in cycle["dailyDataUsage"]:
                                usage_date = datetime.strptime(usage.get("date", "")[:10], "%Y-%m-%d")
                                # Apenas dados do ciclo atual
                                if usage_date >= cycle_start:
                                    total_priority_gb += usage.get("priorityGB", 0) or 0
                                    total_standard_gb += usage.get("standardGB", 0) or 0

                # Calcular dados consolidados
                total_gb = total_priority_gb + total_standard_gb
                total_tb = total_gb / 1024  # Converter para TB
                quota_1tb = 1024  # 1TB em GB
                usage_percentage = (total_gb / quota_1tb) * 100

                # Determinar threshold
                threshold = "normal"
                if usage_percentage >= 100:
                    threshold = "critical"
                elif usage_percentage >= 90:
                    threshold = "danger"
                elif usage_percentage >= 80:
                    threshold = "warning"
                elif usage_percentage >= 70:
                    threshold = "caution"

                # Obter localização
                location = location_dict.get(service_line_number, "Localização não informada")
                nickname = nickname_dict.get(service_line_number, "")

                usage_data.append({
                    "serviceLineNumber": service_line_number,
                    "location": location,
                    "nickname": nickname,
                    "priorityGB": total_priority_gb,
                    "standardGB": total_standard_gb,
                    "totalGB": total_gb,
                    "totalTB": round(total_tb, 3),
                    "usagePercentage": round(usage_percentage, 2),
                    "threshold": threshold,
                    "cycleStart": cycle_start.strftime("%Y-%m-%d"),
                    "cycleEnd": today.strftime("%Y-%m-%d")
                })

        # Ordenar por maior consumo
        usage_data.sort(key=lambda x: x["totalGB"], reverse=True)

        # Estatísticas gerais
        total_lines = len(usage_data)
        lines_70_plus = len([x for x in usage_data if x["usagePercentage"] >= 70])
        lines_80_plus = len([x for x in usage_data if x["usagePercentage"] >= 80])
        lines_90_plus = len([x for x in usage_data if x["usagePercentage"] >= 90])
        lines_100_plus = len([x for x in usage_data if x["usagePercentage"] >= 100])

        return {
            "success": True,
            "usage_data": usage_data,
            "cycle_start": cycle_start.strftime("%d/%m/%Y"),
            "cycle_end": today.strftime("%d/%m/%Y"),
            "total_lines": total_lines,
            "statistics": {
                "lines_70_plus": lines_70_plus,
                "lines_80_plus": lines_80_plus,
                "lines_90_plus": lines_90_plus,
                "lines_100_plus": lines_100_plus,
                "lines_under_70": total_lines - lines_70_plus
            }
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "usage_data": [],
            "statistics": {}
        }


def get_all_accounts_summary():
    """
    Obtém resumo de todas as contas Starlink
    """
    all_accounts_data = {}
    total_summary = {
        "total_service_lines": 0,
        "total_charges": 0,
        "total_usage_70_plus": 0,
        "total_usage_80_plus": 0,
        "total_usage_90_plus": 0,
        "total_usage_100_plus": 0,
        "accounts_with_errors": 0,
        "active_lines": 0,
        "offline_lines": 0,
        "no_data_lines": 0,
        "pending_lines": 0,
        "suspended_lines": 0,
        "unknown_lines": 0,
        "total_counted": 0,
        "count_discrepancy": 0
    }
    
    for account_id in STARLINK_ACCOUNTS.keys():
        try:
            print(f"Obtendo dados para conta: {account_id}")
            
            # Obter dados de faturamento
            billing_data = get_billing_summary(account_id)
            
            # Obter dados de usage
            usage_data = get_billing_usage_data(account_id)
            
            # Obter dados de service lines com status
            service_lines_data = get_service_lines_with_location(account_id)
            
            account_info = get_account_info(account_id)
            
            account_summary = {
                "name": account_info["name"],
                "description": account_info["description"],
                "account_id": account_id,
                "total_service_lines": billing_data.get("total_service_lines", 0),
                "total_charges": billing_data.get("total_charges", 0),
                "billing_success": billing_data.get("success", False),
                "billing_error": billing_data.get("error"),
                "usage_success": usage_data.get("success", False),
                "usage_error": usage_data.get("error"),
                "usage_statistics": usage_data.get("statistics", {}),
                "service_lines_statistics": service_lines_data