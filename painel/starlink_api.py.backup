"""
M√≥dulo para integra√ß√£o com a API da Starlink
"""

import requests
import time
import json
from datetime import datetime, timedelta

# Configura√ß√µes para API
AUTH_URL = "https://api.starlink.com/auth/connect/token"

# Configura√ß√£o de m√∫ltiplas contas Starlink
STARLINK_ACCOUNTS = {
    "ACC-3697602-31930-14": {
        "name": "Conta Prim√°ria",
        "description": "Conta principal de opera√ß√µes"
    },
    "ACC-3697620-11506-11": {
        "name": "Conta Secund√°ria", 
        "description": "Conta secund√°ria regional"
    },
    "ACC-2744134-64041-5": {
        "name": "Conta Principal",
        "description": "Conta principal consolidada"
    },
    "ACC-3697622-49133-20": {
        "name": "Conta Norte",
        "description": "Conta regional norte"
    },
    "ACC-3697611-48655-26": {
        "name": "Conta Sul",
        "description": "Conta regional sul"
    }
}

# Conta padr√£o (pode ser alterada via interface)
DEFAULT_ACCOUNT = "ACC-2744134-64041-5"


def get_api_url(account_id=None):
    """
    Constr√≥i a URL da API para uma conta espec√≠fica
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
    
    return f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}/billing-cycles/query"


def get_account_base_url(account_id=None):
    """
    Constr√≥i a URL base da conta para endpoints espec√≠ficos
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
    
    return f"https://web-api.starlink.com/enterprise/v1/account/{account_id}"


def get_available_accounts():
    """
    Retorna lista de contas dispon√≠veis
    """
    return STARLINK_ACCOUNTS


def get_account_info(account_id):
    """
    Retorna informa√ß√µes de uma conta espec√≠fica
    """
    return STARLINK_ACCOUNTS.get(account_id, {
        "name": "Conta Desconhecida",
        "description": "Conta n√£o encontrada"
    })

CLIENT_ID = "498ca080-3eb2-4a4d-a5d9-3828dbef0194"
CLIENT_SECRET = "fibernetworks_api@2025"

token_data = {
    "access_token": None,
    "expires_at": 0
}


def get_token(client_id, client_secret):
    """
    Obt√©m um novo token de acesso da API Starlink
    """
    payload = {
        "client_id": client_id,
        "client_secret": client_secret,
        "grant_type": "client_credentials"
    }

    headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    }

    try:
        response = requests.post(AUTH_URL, data=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        expires_in = data.get("expires_in", 0)
        token_data["access_token"] = data.get("access_token")
        token_data["expires_at"] = time.time() + expires_in

        return token_data["access_token"]
    except requests.exceptions.RequestException as e:
        raise Exception(f"Erro ao obter token: {e}")


def get_valid_token():
    """
    Retorna um token v√°lido, renovando se necess√°rio
    """
    if not token_data["access_token"] or time.time() >= token_data["expires_at"]:
        return get_token(CLIENT_ID, CLIENT_SECRET)
    return token_data["access_token"]


def query_service_lines(account_id=None):
    """
    Consulta todos os Service Line Numbers da conta
    """
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_line_numbers = []

        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    service_line_numbers.append(service_line_number)
        
        return service_line_numbers

    except requests.exceptions.RequestException as e:
        raise Exception(f"Erro na requisi√ß√£o √† API: {e}")
    except Exception as e:
        raise Exception(f"Erro inesperado: {e}")


def get_service_line_details(service_line_number):
    """
    Obt√©m detalhes espec√≠ficos de um Service Line
    """
    # Esta fun√ß√£o pode ser expandida conforme necess√°rio
    # Por enquanto, retorna informa√ß√µes b√°sicas
    return {
        "service_line_number": service_line_number,
        "status": "Ativo",
        "last_updated": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
    }


def get_billing_summary(account_id=None):
    """
    Obt√©m resumo de faturamento com dados detalhados
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        if not token:
            return {
                "error": "N√£o foi poss√≠vel obter token de acesso",
                "total_service_lines": 0,
                "service_lines": [],
                "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                "account_id": account_id
            }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        total_charges = 0
        billing_cycles = []

        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    # Extrair dados de faturamento
                    billing_info = {
                        "serviceLineNumber": service_line_number,
                        "billing_cycles": result.get("billingCycles", []),
                        "total_amount": 0,
                        "last_billing_date": None
                    }
                    
                    # Processar ciclos de faturamento
                    for cycle in result.get("billingCycles", []):
                        amount = cycle.get("totalAmount", 0)
                        billing_info["total_amount"] += amount
                        total_charges += amount
                        
                        billing_date = cycle.get("billingDate")
                        if billing_date and (not billing_info["last_billing_date"] or billing_date > billing_info["last_billing_date"]):
                            billing_info["last_billing_date"] = billing_date
                    
                    service_lines.append(billing_info)

        return {
            "success": True,
            "total_service_lines": len(service_lines),
            "service_lines": service_lines,
            "total_charges": total_charges,
            "billing_cycles_analyzed": 12,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id,
            "raw_data": data
        }

    except requests.exceptions.RequestException as e:
        return {
            "error": f"Erro na requisi√ß√£o √† API: {e}",
            "total_service_lines": 0,
            "service_lines": [],
            "total_charges": 0,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }
    except Exception as e:
        return {
            "error": f"Erro inesperado: {e}",
            "total_service_lines": 0,
            "service_lines": [],
            "total_charges": 0,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }


def test_api_connection(account_id=None):
    """
    Testa a conex√£o com a API Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        # Primeiro, testa a autentica√ß√£o
        token = get_valid_token()
        if not token:
            return {
                "status": "error",
                "message": "Falha na autentica√ß√£o",
                "details": "N√£o foi poss√≠vel obter token de acesso",
                "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            }

        # Testa uma requisi√ß√£o simples √† API
        payload = {
            "serviceLinesFilter": [],
            "previousBillingCycles": 1,
            "pageIndex": 0,
            "pageLimit": 1
        }

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        
        # Se chegou at√© aqui, a conex√£o est√° OK
        expires_at = datetime.fromtimestamp(token_data['expires_at']).strftime('%d/%m/%Y %H:%M:%S')
        
        return {
            "status": "success",
            "message": "Conex√£o com API Starlink estabelecida com sucesso",
            "details": f"Token v√°lido at√©: {expires_at}",
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "account_id": account_id
        }

    except requests.exceptions.RequestException as e:
        return {
            "status": "error",
            "message": "Falha na comunica√ß√£o com a API",
            "details": str(e),
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }
    except Exception as e:
        return {
            "status": "error",
            "message": "Erro inesperado na verifica√ß√£o da API",
            "details": str(e),
            "timestamp": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }


def get_detailed_service_lines(account_id=None):
    """
    Obt√©m lista detalhada de Service Lines com informa√ß√µes completas de localiza√ß√£o
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 100
    }

    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endere√ßos
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber")
                
                if service_line_number:
                    # Extrair informa√ß√µes de localiza√ß√£o dos dados da API
                    location_info = "Localiza√ß√£o n√£o informada"
                    
                    # Primeiro tentar usar os dados de endere√ßos se houver addressReferenceId
                    address_ref_id = None
                    if "addressReferenceId" in result:
                        address_ref_id = result["addressReferenceId"]
                    elif "serviceLocation" in result and isinstance(result["serviceLocation"], dict):
                        address_ref_id = result["serviceLocation"].get("addressReferenceId")
                    
                    if address_ref_id and address_ref_id in addresses_dict:
                        addr = addresses_dict[address_ref_id]
                        location_parts = []
                        if addr["locality"]:
                            location_parts.append(addr["locality"])
                        if addr["state"]:
                            location_parts.append(addr["state"])
                        if addr["country"]:
                            location_parts.append(addr["country"])
                        
                        if location_parts:
                            location_info = ", ".join(location_parts)
                        elif addr["formatted"]:
                            # Usar endere√ßo formatado como fallback
                            location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                    
                    # Fallback: tentar extrair de outros campos se n√£o encontrou nos endere√ßos
                    if location_info == "Localiza√ß√£o n√£o informada":
                        if "nickname" in result and result["nickname"]:
                            location_info = result["nickname"]
                        elif "serviceAddress" in result and result["serviceAddress"]:
                            location_info = str(result["serviceAddress"])
                        elif "latitude" in result and "longitude" in result:
                            location_info = f"GPS: {result['latitude']}, {result['longitude']}"
                    
                    service_lines.append({
                        "index": i,
                        "serviceLineNumber": service_line_number,
                        "status": "Ativo",  # Pode ser expandido com dados reais
                        "serviceLocation": location_info,
                        "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                        "billingCycles": len(result.get("billingCycles", [])),
                        "addressReferenceId": address_ref_id,
                        "rawData": result  # Para debuging ou relat√≥rios detalhados
                    })

        return {
            "success": True,
            "service_lines": service_lines,
            "total": len(service_lines),
            "addresses_loaded": len(addresses_dict),
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Fun√ß√£o para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("‚ùå N√£o foi poss√≠vel obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"üîç Fazendo requisi√ß√£o √† API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("üìã RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"üìä Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"üì¶ Conte√∫do dispon√≠vel: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"üìà Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\nüî∏ RESULTADO {i+1}:")
                    print(f"   üìã Campos dispon√≠veis: {list(result.keys())}")
                    
                    # Mostrar campos espec√≠ficos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   üìÅ {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   üìù {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ‚úèÔ∏è  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localiza√ß√£o
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   üó∫Ô∏è  CAMPOS DE LOCALIZA√á√ÉO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ‚úÖ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("üìã DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"‚ùå Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint espec√≠fico de addresses fornecido pelo usu√°rio
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\nüîç TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n‚úÖ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conte√∫do completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n‚ùå ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå ERRO DE REQUISI√á√ÉO: {e}")
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        print(f"\n‚ùå ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa m√∫ltiplos endpoints baseados no padr√£o da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"üîç Testando endpoint: {endpoint}")
        print(f"üìç URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"üìä Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Sucesso!")
                print(f"üìÑ Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"üìã Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"üìã Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"üìÑ DADOS:")
                print(data)
                
            else:
                print(f"‚ùå Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"‚ùå Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obt√©m todos os endere√ßos cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endere√ßos para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obt√©m Service Lines com localiza√ß√£o correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endere√ßos
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informa√ß√µes de localiza√ß√£o
                location_info = "Localiza√ß√£o n√£o informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endere√ßos
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endere√ßo formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se n√£o encontrou nos endere√ßos
                if location_info == "Localiza√ß√£o n√£o informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se h√° dados recentes (√∫ltimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se n√£o conseguir processar a data, mant√©m como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estat√≠sticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status poss√≠veis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se h√° discrep√¢ncia na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Fun√ß√£o para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("‚ùå N√£o foi poss√≠vel obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"üîç Fazendo requisi√ß√£o √† API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("üìã RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"üìä Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"üì¶ Conte√∫do dispon√≠vel: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"üìà Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\nüî∏ RESULTADO {i+1}:")
                    print(f"   üìã Campos dispon√≠veis: {list(result.keys())}")
                    
                    # Mostrar campos espec√≠ficos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   üìÅ {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   üìù {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ‚úèÔ∏è  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localiza√ß√£o
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   üó∫Ô∏è  CAMPOS DE LOCALIZA√á√ÉO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ‚úÖ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("üìã DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"‚ùå Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint espec√≠fico de addresses fornecido pelo usu√°rio
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\nüîç TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n‚úÖ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conte√∫do completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n‚ùå ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå ERRO DE REQUISI√á√ÉO: {e}")
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        print(f"\n‚ùå ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa m√∫ltiplos endpoints baseados no padr√£o da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"üîç Testando endpoint: {endpoint}")
        print(f"üìç URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"üìä Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Sucesso!")
                print(f"üìÑ Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"üìã Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"üìã Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"üìÑ DADOS:")
                print(data)
                
            else:
                print(f"‚ùå Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"‚ùå Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obt√©m todos os endere√ßos cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endere√ßos para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obt√©m Service Lines com localiza√ß√£o correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endere√ßos
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informa√ß√µes de localiza√ß√£o
                location_info = "Localiza√ß√£o n√£o informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endere√ßos
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endere√ßo formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se n√£o encontrou nos endere√ßos
                if location_info == "Localiza√ß√£o n√£o informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se h√° dados recentes (√∫ltimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se n√£o conseguir processar a data, mant√©m como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estat√≠sticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status poss√≠veis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se h√° discrep√¢ncia na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_api_response(account_id=None):
    """
    Fun√ß√£o para debug - mostra no console o resultado completo da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    payload = {
        "serviceLinesFilter": [],
        "previousBillingCycles": 12,
        "pageIndex": 0,
        "pageLimit": 5  # Limitar para debug
    }

    try:
        token = get_valid_token()
        if not token:
            print("‚ùå N√£o foi poss√≠vel obter token de acesso")
            return

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"üîç Fazendo requisi√ß√£o √† API Starlink - Conta: {account_id}...")
        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        print("\n" + "="*80)
        print("üìã RESULTADO COMPLETO DA API STARLINK")
        print("="*80)
        
        # Mostrar estrutura geral
        print(f"üìä Estrutura principal: {list(data.keys())}")
        
        if "content" in data:
            print(f"üì¶ Conte√∫do dispon√≠vel: {list(data['content'].keys())}")
            
            if "results" in data["content"]:
                results = data["content"]["results"]
                print(f"üìà Total de resultados: {len(results)}")
                
                # Mostrar detalhes de cada resultado
                for i, result in enumerate(results[:3]):  # Mostrar apenas os 3 primeiros
                    print(f"\nüî∏ RESULTADO {i+1}:")
                    print(f"   üìã Campos dispon√≠veis: {list(result.keys())}")
                    
                    # Mostrar campos espec√≠ficos
                    for key, value in result.items():
                        if isinstance(value, dict):
                            print(f"   üìÅ {key}: {list(value.keys())} (dict)")
                        elif isinstance(value, list):
                            print(f"   üìù {key}: {len(value)} itens (list)")
                        else:
                            print(f"   ‚úèÔ∏è  {key}: {str(value)[:100]}...")
                    
                    # Procurar campos que podem conter localiza√ß√£o
                    location_fields = [
                        'serviceLocation', 'location', 'address', 'site', 
                        'serviceAddress', 'installationAddress', 'billingAddress',
                        'coordinates', 'geoLocation', 'region', 'country', 
                        'city', 'state', 'zipCode', 'postalCode'
                    ]
                    
                    print(f"\n   üó∫Ô∏è  CAMPOS DE LOCALIZA√á√ÉO ENCONTRADOS:")
                    for field in location_fields:
                        if field in result:
                            print(f"   ‚úÖ {field}: {result[field]}")
                    
                    print("-" * 60)
        
        print("\n" + "="*80)
        print("üìã DADOS BRUTOS COMPLETOS (JSON)")
        print("="*80)
        import json
        print(json.dumps(data, indent=2, ensure_ascii=False))
        
    except Exception as e:
        print(f"‚ùå Erro no debug: {e}")


def debug_addresses_endpoint(account_id=None):
    """
    Testa o endpoint espec√≠fico de addresses fornecido pelo usu√°rio
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"https://web-api.starlink.com/enterprise/v1/account/{account_id}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        print(f"\nüîç TESTANDO ENDPOINT ADDRESSES:")
        print(f"URL: {addresses_url}")
        print(f"Headers: {headers}")
        print("-" * 80)

        response = requests.get(addresses_url, headers=headers)
        
        print(f"Status Code: {response.status_code}")
        print(f"Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"\n‚úÖ SUCESSO! Dados retornados:")
            print(f"Tipo de resposta: {type(data)}")
            print(f"Conte√∫do completo:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
            return {"success": True, "data": data}
        else:
            print(f"\n‚ùå ERRO HTTP {response.status_code}")
            print(f"Resposta: {response.text}")
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå ERRO DE REQUISI√á√ÉO: {e}")
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        print(f"\n‚ùå ERRO INESPERADO: {e}")
        return {"error": f"Erro inesperado: {e}"}


def debug_multiple_endpoints(account_id=None):
    """
    Testa m√∫ltiplos endpoints baseados no padr√£o da API
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    base_url = f"https://web-api.starlink.com/enterprise/v1/accounts/{account_id}"
    
    endpoints_to_test = [
        "addresses",
        "service-lines",
        "terminals",
        "locations",
        "sites",
        "subscriptions"
    ]
    
    results = {}
    
    for endpoint in endpoints_to_test:
        url = f"{base_url}/{endpoint}"
        print(f"\n{'='*60}")
        print(f"üîç Testando endpoint: {endpoint}")
        print(f"üìç URL: {url}")
        print(f"{'='*60}")
        
        try:
            token = get_valid_token()
            headers = {
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json"
            }
            
            response = requests.get(url, headers=headers)
            print(f"üìä Status: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Sucesso!")
                print(f"üìÑ Tipo: {type(data)}")
                
                if isinstance(data, dict):
                    print(f"üìã Chaves: {list(data.keys())}")
                elif isinstance(data, list):
                    print(f"üìã Lista com {len(data)} items")
                
                results[endpoint] = {"success": True, "data": data}
                print(f"üìÑ DADOS:")
                print(data)
                
            else:
                print(f"‚ùå Erro {response.status_code}: {response.text}")
                results[endpoint] = {"success": False, "error": f"HTTP {response.status_code}"}
                
        except Exception as e:
            print(f"‚ùå Erro: {e}")
            results[endpoint] = {"success": False, "error": str(e)}
    
    return results


def get_starlink_addresses(account_id=None):
    """
    Obt√©m todos os endere√ßos cadastrados na conta Starlink
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    addresses_url = f"{get_account_base_url(account_id)}/addresses"
    
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        response = requests.get(addresses_url, headers=headers)
        response.raise_for_status()
        
        if response.status_code == 200:
            data = response.json()
            addresses = data.get("content", {}).get("results", [])
            
            # Processar endere√ßos para facilitar o uso
            processed_addresses = {}
            for addr in addresses:
                addr_id = addr.get("addressReferenceId")
                if addr_id:
                    processed_addresses[addr_id] = {
                        "id": addr_id,
                        "locality": addr.get("locality", ""),
                        "state": addr.get("administrativeAreaCode", ""),
                        "country": addr.get("regionCode", ""),
                        "formatted": addr.get("formattedAddress", ""),
                        "coordinates": f"{addr.get('latitude', '')}, {addr.get('longitude', '')}" if addr.get('latitude') and addr.get('longitude') else "",
                        "postal_code": addr.get("postalCode", "")
                    }
            
            return {
                "success": True,
                "addresses": processed_addresses,
                "total": len(processed_addresses)
            }
        else:
            return {"error": f"HTTP {response.status_code}: {response.text}"}

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def get_service_lines_with_location(account_id=None):
    """
    Obt√©m Service Lines com localiza√ß√£o correta usando o endpoint /service-lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Primeiro, obter dados dos endere√ßos
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Usar o endpoint correto para Service Lines com limit maior
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        service_lines = []
        correlations_found = 0
        
        if "content" in data and "results" in data["content"]:
            for i, result in enumerate(data["content"]["results"], 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Sempre processar todos os Service Lines, mesmo sem serviceLineNumber
                # Extrair informa√ß√µes de localiza√ß√£o
                location_info = "Localiza√ß√£o n√£o informada"
                address_ref_id = result.get("addressReferenceId")
                
                # Tentar correlacionar com endere√ßos
                if address_ref_id and address_ref_id in addresses_dict:
                    addr = addresses_dict[address_ref_id]
                    location_parts = []
                    if addr["locality"]:
                        location_parts.append(addr["locality"])
                    if addr["state"]:
                        location_parts.append(addr["state"])
                    if addr["country"]:
                        location_parts.append(addr["country"])
                    
                    if location_parts:
                        location_info = ", ".join(location_parts)
                        correlations_found += 1
                    elif addr["formatted"]:
                        # Usar endere√ßo formatado como fallback
                        location_info = addr["formatted"][:50] + "..." if len(addr["formatted"]) > 50 else addr["formatted"]
                        correlations_found += 1
                
                # Fallback: tentar extrair de outros campos se n√£o encontrou nos endere√ßos
                if location_info == "Localiza√ß√£o n√£o informada":
                    if "nickname" in result and result["nickname"]:
                        location_info = result["nickname"]
                
                # Determinar status detalhado
                detailed_status = "Ativo"
                status_class = "active"
                
                if not result.get("active", True):
                    detailed_status = "Offline"
                    status_class = "offline"
                else:
                    # Verificar se h√° dados recentes (√∫ltimos 30 dias)
                    from datetime import datetime, timedelta
                    import dateutil.parser
                    
                    try:
                        end_date = result.get("endDate")
                        if end_date:
                            end_datetime = dateutil.parser.parse(end_date)
                            thirty_days_ago = datetime.now(end_datetime.tzinfo) - timedelta(days=30)
                            
                            if end_datetime < thirty_days_ago:
                                detailed_status = "Sem Dados"
                                status_class = "no_data"
                    except:
                        pass  # Se n√£o conseguir processar a data, mant√©m como ativo
                
                service_lines.append({
                    "index": i,
                    "serviceLineNumber": service_line_number,
                    "nickname": result.get("nickname", ""),
                    "status": detailed_status,
                    "statusClass": status_class,
                    "serviceLocation": location_info,
                    "lastUpdate": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
                    "addressReferenceId": address_ref_id,
                    "startDate": result.get("startDate", ""),
                    "endDate": result.get("endDate", ""),
                    "publicIp": result.get("publicIp", ""),
                    "hasAddress": bool(address_ref_id and address_ref_id in addresses_dict),
                    "rawData": result  # Para debug
                })

        # Calcular estat√≠sticas detalhadas
        total_service_lines = len(service_lines)
        with_address = len([sl for sl in service_lines if sl["hasAddress"]])
        without_address = total_service_lines - with_address
        with_nickname = len([sl for sl in service_lines if sl["nickname"]])
        
        # Contar por status detalhado - incluindo TODOS os status poss√≠veis
        active_lines = len([sl for sl in service_lines if sl["status"] == "Ativo"])
        offline_lines = len([sl for sl in service_lines if sl["status"] == "Offline"])
        no_data_lines = len([sl for sl in service_lines if sl["status"] == "Sem Dados"])
        pending_lines = len([sl for sl in service_lines if sl["status"] == "Pendente"])
        suspended_lines = len([sl for sl in service_lines if sl["status"] == "Suspenso"])
        indeterminate_lines = len([sl for sl in service_lines if sl["status"] == "Indeterminado"])
        
        # Verificar se h√° discrep√¢ncia na contagem
        total_counted = active_lines + offline_lines + no_data_lines + pending_lines + suspended_lines + indeterminate_lines
        discrepancy = total_service_lines - total_counted
        
        return {
            "success": True,
            "service_lines": service_lines,
            "total": total_service_lines,
            "addresses_loaded": len(addresses_dict),
            "correlations_found": correlations_found,
            "statistics": {
                "total_service_lines": total_service_lines,
                "with_address": with_address,
                "without_address": without_address,
                "with_nickname": with_nickname,
                "active_lines": active_lines,
                "offline_lines": offline_lines,
                "no_data_lines": no_data_lines,
                "pending_lines": pending_lines,
                "suspended_lines": suspended_lines,
                "indeterminate_lines": indeterminate_lines,
                "total_counted": total_counted
            },
            "account_id": account_id,
            "last_update": datetime.now().strftime("%d/%m/%Y %H:%M:%S")
        }

    except requests.exceptions.RequestException as e:
        return {"error": f"Erro na requisi√ß√£o √† API: {e}"}
    except Exception as e:
        return {"error": f"Erro inesperado: {e}"}


def debug_service_line_status(account_id=None):
    """
    Debug espec√≠fico para analisar todos os status poss√≠veis das Service Lines
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        if not token:
            return {"error": "N√£o foi poss√≠vel obter token de acesso"}

        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Usar o endpoint correto para Service Lines
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=200"
        
        response = requests.get(service_lines_url, headers=headers)
        response.raise_for_status()
        data = response.json()

        print(f"\nüîç DEBUG - AN√ÅLISE DE STATUS DAS SERVICE LINES - Conta: {account_id}")
        print("=" * 80)
        
        status_analysis = {}
        field_analysis = {}
        total_lines = 0
        
        if "content" in data and "results" in data["content"]:
            results = data["content"]["results"]
            total_lines = len(results)
            print(f"üìä Total de Service Lines encontradas: {total_lines}")
            
            for i, result in enumerate(results, 1):
                service_line_number = result.get("serviceLineNumber", f"SL-UNKNOWN-{i}")
                
                # Analisar todos os campos relacionados a status
                fields_of_interest = [
                    'active', 'status', 'state', 'enabled', 'disabled', 'suspended',
                    'startDate', 'endDate', 'activationDate', 'suspensionDate',
                    'billingStatus', 'serviceStatus', 'lineStatus', 'accountStatus',
                    'subscriptionStatus', 'connectionStatus', 'operationalStatus'
                ]
                
                print(f"\nüìã Service Line {i}: {service_line_number}")
                
                # Coletar todos os campos dispon√≠veis
                for field in fields_of_interest:
                    if field in result:
                        value = result[field]
                        print(f"   ‚úÖ {field}: {value}")
                        
                        # Contar ocorr√™ncias de cada campo
                        if field not in field_analysis:
                            field_analysis[field] = {}
                        
                        value_str = str(value)
                        if value_str not in field_analysis[field]:
                            field_analysis[field][value_str] = 0
                        field_analysis[field][value_str] += 1
                
                # Determinar status usando l√≥gica melhorada
                determined_status = determine_enhanced_status(result)
                print(f"   üéØ Status Determinado: {determined_status}")
                
                # Contar status
                if determined_status not in status_analysis:
                    status_analysis[determined_status] = 0
                status_analysis[determined_status] += 1
                
                # Mostrar apenas os primeiros 10 para n√£o poluir muito
                if i >= 10:
                    print(f"\n... (mostrando apenas os primeiros 10 de {total_lines})")
                    break
        
        print(f"\nüìä RESUMO DE STATUS:")
        print("-" * 40)
        total_counted = 0
        for status, count in status_analysis.items():
            print(f"   {status}: {count}")
            total_counted += count
        
        print(f"\nüìä Total contabilizado: {total_counted} de {total_lines}")
        if total_counted != total_lines:
            print(f"‚ö†Ô∏è  DISCREP√ÇNCIA: {total_lines - total_counted} Service Lines n√£o contabilizadas!")
        
        print(f"\nüìã AN√ÅLISE DE CAMPOS:")
        print("-" * 40)
        for field, values in field_analysis.items():
            print(f"   {field}:")
            for value, count in values.items():
                print(f"      {value}: {count}")
        
        return {
            "success": True,
            "total_lines": total_lines,
            "status_analysis": status_analysis,
            "field_analysis": field_analysis,
            "total_counted": total_counted,
            "discrepancy": total_lines - total_counted
        }

    except Exception as e:
        print(f"‚ùå Erro no debug de status: {e}")
        return {"error": str(e)}


def determine_enhanced_status(service_line_data):
    """
    Determina o status de uma Service Line usando l√≥gica melhorada
    """
    from datetime import datetime, timedelta
    import dateutil.parser
    
    # Verificar campo 'active' primeiro
    active_field = service_line_data.get("active")
    if active_field is False:
        return "Offline"
    
    # Verificar campos de status diretos
    status_fields = ['status', 'state', 'serviceStatus', 'lineStatus', 'operationalStatus']
    for field in status_fields:
        if field in service_line_data:
            value = str(service_line_data[field]).lower()
            if value in ['inactive', 'disabled', 'suspended', 'offline', 'down']:
                return "Offline"
            elif value in ['pending', 'provisioning', 'installing', 'activating']:
                return "Pendente"
            elif value in ['active', 'enabled', 'online', 'up', 'operational']:
                return "Ativo"
    
    # Verificar datas para determinar se est√° ativo
    try:
        start_date = service_line_data.get("startDate")
        end_date = service_line_data.get("endDate")
        
        if start_date:
            start_datetime = dateutil.parser.parse(start_date)
            now = datetime.now(start_datetime.tzinfo) if start_datetime.tzinfo else datetime.now()
            
            # Se ainda n√£o come√ßou
            if start_datetime > now:
                return "Pendente"
        
        if end_date:
            end_datetime = dateutil.parser.parse(end_date)
            now = datetime.now(end_datetime.tzinfo) if end_datetime.tzinfo else datetime.now()
            
            # Se j√° terminou h√° mais de 30 dias
            thirty_days_ago = now - timedelta(days=30)
            if end_datetime < thirty_days_ago:
                return "Sem Dados"
            # Se terminou recentemente
            elif end_datetime < now:
                return "Offline"
    except:
        pass  # Se houver erro no parsing de datas, continua
    
    # Verificar outros campos que podem indicar status
    suspension_date = service_line_data.get("suspensionDate")
    if suspension_date:
        try:
            susp_datetime = dateutil.parser.parse(suspension_date)
            now = datetime.now(susp_datetime.tzinfo) if susp_datetime.tzinfo else datetime.now()
            if susp_datetime <= now:
                return "Suspenso"
        except:
            pass
    
    # Se chegou at√© aqui e active n√£o √© False, assumir ativo
    if active_field is not False:
        return "Ativo"
    
    # Caso padr√£o
    return "Indeterminado"


def get_billing_usage_data(account_id=None):
    """
    Obt√©m dados de consumo de franquia do ciclo atual com localiza√ß√£o
    """
    if account_id is None:
        account_id = DEFAULT_ACCOUNT
        
    try:
        token = get_valid_token()
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json"
        }

        # Calcular o per√≠odo do ciclo atual (do dia 3 at√© hoje)
        today = datetime.now()
        if today.day >= 3:
            cycle_start = today.replace(day=3)
        else:
            # Se estamos antes do dia 3, o ciclo come√ßou no m√™s anterior
            last_month = today.replace(day=1) - timedelta(days=1)
            cycle_start = last_month.replace(day=3)

        # Primeiro, obter dados dos endere√ßos para correlacionar localiza√ß√£o
        addresses_result = get_starlink_addresses(account_id)
        addresses_dict = {}
        if addresses_result.get("success"):
            addresses_dict = addresses_result.get("addresses", {})

        # Obter dados dos Service Lines com localiza√ß√£o
        service_lines_url = f"{get_account_base_url(account_id)}/service-lines?limit=100"
        service_lines_response = requests.get(service_lines_url, headers=headers)
        service_lines_response.raise_for_status()
        service_lines_data = service_lines_response.json()

        # Criar dicion√°rio de localiza√ß√£o por Service Line
        location_dict = {}
        nickname_dict = {}
        
        if "content" in service_lines_data and "results" in service_lines_data["content"]:
            for result in service_lines_data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                if service_line_number:
                    # Obter localiza√ß√£o
                    location_info = "Localiza√ß√£o n√£o informada"
                    address_ref_id = result.get("addressReferenceId")
                    
                    if address_ref_id and address_ref_id in addresses_dict:
                        addr = addresses_dict[address_ref_id]
                        location_parts = []
                        if addr["locality"]:
                            location_parts.append(addr["locality"])
                        if addr["state"]:
                            location_parts.append(addr["state"])
                        if addr["country"]:
                            location_parts.append(addr["country"])
                        
                        if location_parts:
                            location_info = ", ".join(location_parts)
                        elif addr["formatted"]:
                            location_info = addr["formatted"]
                    
                    # Usar nickname como fallback se n√£o tiver localiza√ß√£o
                    nickname = result.get("nickname", "")
                    if nickname and location_info == "Localiza√ß√£o n√£o informada":
                        location_info = nickname
                    
                    location_dict[service_line_number] = location_info
                    nickname_dict[service_line_number] = nickname

        # Configurar payload para buscar dados do ciclo atual
        payload = {
            "serviceLinesFilter": [],
            "previousBillingCycles": 1,  # Apenas o ciclo atual
            "pageIndex": 0,
            "pageLimit": 100
        }

        api_url = get_api_url(account_id)
        response = requests.post(api_url, json=payload, headers=headers)
        response.raise_for_status()
        data = response.json()

        # Processar dados de consumo
        usage_data = []
        if "content" in data and "results" in data["content"]:
            for result in data["content"]["results"]:
                service_line_number = result.get("serviceLineNumber")
                total_priority_gb = 0
                total_standard_gb = 0
                
                if "billingCycles" in result:
                    for cycle in result["billingCycles"]:
                        if "dailyDataUsage" in cycle:
                            for usage in cycle["dailyDataUsage"]:
                                usage_date = datetime.strptime(usage.get("date", "")[:10], "%Y-%m-%d")
                                # Apenas dados do ciclo atual
                                if usage_date >= cycle_start:
                                    total_priority_gb += usage.get("priorityGB", 0) or 0
                                    total_standard_gb += usage.get("standardGB", 0) or 0

                # Calcular dados consolidados
                total_gb = total_priority_gb + total_standard_gb
                total_tb = total_gb / 1024  # Converter para TB
                quota_1tb = 1024  # 1TB em GB
                usage_percentage = (total_gb / quota_1tb) * 100

                # Determinar threshold
                threshold = "normal"
                if usage_percentage >= 100:
                    threshold = "critical"
                elif usage_percentage >= 90:
                    threshold = "danger"
                elif usage_percentage >= 80:
                    threshold = "warning"
                elif usage_percentage >= 70:
                    threshold = "caution"

                # Obter localiza√ß√£o
                location = location_dict.get(service_line_number, "Localiza√ß√£o n√£o informada")
                nickname = nickname_dict.get(service_line_number, "")

                usage_data.append({
                    "serviceLineNumber": service_line_number,
                    "location": location,
                    "nickname": nickname,
                    "priorityGB": total_priority_gb,
                    "standardGB": total_standard_gb,
                    "totalGB": total_gb,
                    "totalTB": round(total_tb, 3),
                    "usagePercentage": round(usage_percentage, 2),
                    "threshold": threshold,
                    "cycleStart": cycle_start.strftime("%Y-%m-%d"),
                    "cycleEnd": today.strftime("%Y-%m-%d")
                })

        # Ordenar por maior consumo
        usage_data.sort(key=lambda x: x["totalGB"], reverse=True)

        # Estat√≠sticas gerais
        total_lines = len(usage_data)
        lines_70_plus = len([x for x in usage_data if x["usagePercentage"] >= 70])
        lines_80_plus = len([x for x in usage_data if x["usagePercentage"] >= 80])
        lines_90_plus = len([x for x in usage_data if x["usagePercentage"] >= 90])
        lines_100_plus = len([x for x in usage_data if x["usagePercentage"] >= 100])

        return {
            "success": True,
            "usage_data": usage_data,
            "cycle_start": cycle_start.strftime("%d/%m/%Y"),
            "cycle_end": today.strftime("%d/%m/%Y"),
            "total_lines": total_lines,
            "statistics": {
                "lines_70_plus": lines_70_plus,
                "lines_80_plus": lines_80_plus,
                "lines_90_plus": lines_90_plus,
                "lines_100_plus": lines_100_plus,
                "lines_under_70": total_lines - lines_70_plus
            }
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "usage_data": [],
            "statistics": {}
        }


def get_all_accounts_summary():
    """
    Obt√©m resumo de todas as contas Starlink
    """
    all_accounts_data = {}
    total_summary = {
        "total_service_lines": 0,
        "total_charges": 0,
        "total_usage_70_plus": 0,
        "total_usage_80_plus": 0,
        "total_usage_90_plus": 0,
        "total_usage_100_plus": 0,
        "accounts_with_errors": 0,
        "active_lines": 0,
        "offline_lines": 0,
        "no_data_lines": 0,
        "pending_lines": 0,
        "suspended_lines": 0,
        "unknown_lines": 0,
        "total_counted": 0,
        "count_discrepancy": 0
    }
    
    for account_id in STARLINK_ACCOUNTS.keys():
        try:
            print(f"Obtendo dados para conta: {account_id}")
            
            # Obter dados de faturamento
            billing_data = get_billing_summary(account_id)
            
            # Obter dados de usage
            usage_data = get_billing_usage_data(account_id)
            
            # Obter dados de service lines com status
            service_lines_data = get_service_lines_with_location(account_id)
            
            account_info = get_account_info(account_id)
            
            account_summary = {
                "name": account_info["name"],
                "description": account_info["description"],
                "account_id": account_id,
                "total_service_lines": billing_data.get("total_service_lines", 0),
                "total_charges": billing_data.get("total_charges", 0),
                "billing_success": billing_data.get("success", False),
                "billing_error": billing_data.get("error"),
                "usage_success": usage_data.get("success", False),
                "usage_error": usage_data.get("error"),
                "usage_statistics": usage_data.get("statistics", {}),
                "service_lines_statistics": service_lines_data